"""Generate a standalone Python replication script from analysis state."""

from __future__ import annotations

from mcpower import __version__ as _mcpower_version

from mcpower_gui.state import build_correlations_string, build_variable_type_string

_CITATION = "Lenartowicz, P. (2025). MCPower: Monte Carlo Power Analysis for Statistical Models. Zenodo. DOI: 10.5281/zenodo.16502734"


def generate_script(
    state_snapshot: dict,
    analysis_params: dict,
    mode: str,
    data_file_path: str | None = None,
) -> str:
    """Build a complete Python script mirroring the worker logic.

    Parameters
    ----------
    state_snapshot : dict
        JSON-serializable model state (from ModelState.snapshot() or worker).
    analysis_params : dict
        Per-run parameters from the Analysis tab.
    mode : str
        "power" or "sample_size".
    data_file_path : str | None
        Path to uploaded CSV file, if any.

    Returns
    -------
    str
        Complete Python script that reproduces the analysis.
    """
    lines: list[str] = []
    lines.append(f"# Generated by MCPower v{_mcpower_version}")
    lines.append(f"# Cite: {_CITATION}")
    lines.append("")
    lines.append("from mcpower import MCPower")

    if data_file_path:
        lines.append("import csv")
    lines.append("")

    # Data loading
    if data_file_path:
        lines.append(
            f'with open({data_file_path!r}, newline="", encoding="utf-8-sig") as _f:'
        )
        lines.append("    _rows = list(csv.DictReader(_f))")
        lines.append("data = {}")
        lines.append("for _col in _rows[0]:")
        lines.append('    if not _col or _col.startswith("Unnamed"):')
        lines.append("        continue")
        lines.append("    _raw = [_r[_col] for _r in _rows]")
        lines.append("    try:")
        lines.append("        data[_col] = [float(_v) for _v in _raw]")
        lines.append("    except (ValueError, TypeError):")
        lines.append("        data[_col] = _raw")
        lines.append("")

    # Model creation
    model_type = state_snapshot.get("model_type", "linear_regression")
    if model_type == "anova":
        lines.append("# Model type: ANOVA (all predictors are factors)")
    formula = state_snapshot.get("formula", "")
    lines.append(f'model = MCPower("{formula}")')

    # Upload data
    if data_file_path:
        preserve = state_snapshot.get("preserve_correlation", "partial")
        # Build data_types with non-default reference levels
        factor_refs = state_snapshot.get("factor_reference_levels", {})
        factor_labels = state_snapshot.get("factor_level_labels", {})
        data_types = {}
        for factor_name, ref_level in factor_refs.items():
            level_labels_list = factor_labels.get(factor_name, [])
            if level_labels_list and ref_level != level_labels_list[0]:
                data_types[factor_name] = ("factor", ref_level)

        if data_types:
            lines.append(f"data_types = {data_types!r}")
            lines.append(
                f'model.upload_data(data, preserve_correlation="{preserve}",'
                f" preserve_factor_level_names=True, data_types=data_types)"
            )
        else:
            lines.append(
                f'model.upload_data(data, preserve_correlation="{preserve}",'
                f" preserve_factor_level_names=True)"
            )

    # Variable types â€” exclude data columns when data is uploaded
    # (upload_data auto-detects types with correct factor labels)
    vtypes = state_snapshot.get("variable_types", {})
    if data_file_path:
        data_cols = set(state_snapshot.get("uploaded_columns", []))
        vtypes = {k: v for k, v in vtypes.items() if k not in data_cols}
    vtype_str = build_variable_type_string(vtypes)
    if vtype_str:
        lines.append(f'model.set_variable_type("{vtype_str}")')

    # Effects
    effects = state_snapshot.get("effects", {})
    if effects:
        effects_str = ", ".join(f"{k}={v}" for k, v in effects.items())
        lines.append(f'model.set_effects("{effects_str}")')

    # Cluster configurations (mixed models)
    cluster_configs = state_snapshot.get("cluster_configs", [])
    for cluster_cfg in cluster_configs:
        gv = cluster_cfg["grouping_var"]
        parts = [f'model.set_cluster("{gv}"']
        parts.append(f"ICC={cluster_cfg['ICC']}")
        if "n_clusters" in cluster_cfg:
            parts.append(f"n_clusters={cluster_cfg['n_clusters']}")
        if "n_per_parent" in cluster_cfg:
            parts.append(f"n_per_parent={cluster_cfg['n_per_parent']}")
        if cluster_cfg.get("random_slopes"):
            parts.append(f"random_slopes={cluster_cfg['random_slopes']!r}")
            parts.append(f"slope_variance={cluster_cfg.get('slope_variance', 0.0)}")
            parts.append(
                f"slope_intercept_corr={cluster_cfg.get('slope_intercept_corr', 0.0)}"
            )
        lines.append(", ".join(parts) + ")")

    # Simulation settings
    n_sims = state_snapshot.get("n_simulations", 1600)
    n_sims_mm = state_snapshot.get("n_simulations_mixed_model", 800)
    lines.append(f'model.set_simulations({n_sims}, model_type="linear")')
    lines.append(f'model.set_simulations({n_sims_mm}, model_type="mixed")')

    alpha = state_snapshot.get("alpha", 0.05)
    lines.append(f"model.set_alpha({alpha})")

    target_power = state_snapshot.get("target_power", 80.0)
    lines.append(f"model.set_power({target_power})")

    seed = state_snapshot.get("seed", 2137)
    lines.append(f"model.set_seed({seed})")

    max_failed = state_snapshot.get("max_failed_simulations", 0.03)
    lines.append(f"model.set_max_failed_simulations({max_failed})")

    # Parallel ("mixedmodels" is the default, only emit when different)
    parallel_val = state_snapshot.get("parallel", "mixedmodels")
    if parallel_val is False:
        lines.append("model.set_parallel(False)")
    elif parallel_val is True:
        n_cores = state_snapshot.get("n_cores", 1)
        lines.append(f"model.set_parallel(enable=True, n_cores={n_cores})")

    # Scenario configs
    scenario_configs = state_snapshot.get("scenario_configs", {})
    if scenario_configs:
        lines.append(f"model.set_scenario_configs({scenario_configs!r})")

    # Correlations
    correlations = state_snapshot.get("correlations", {})
    if correlations:
        corr_str = build_correlations_string(correlations)
        lines.append(f'model.set_correlations("{corr_str}")')

    lines.append("model.apply()")
    lines.append("")

    # Analysis call
    correction = analysis_params.get("correction") or None
    scenarios = analysis_params.get("scenarios", False)
    summary = "short"
    target_test = analysis_params.get("target_test", "all")
    test_formula = analysis_params.get("test_formula", "")

    corr_arg = f'"{correction}"' if correction else "None"
    tf_arg = f'"{test_formula}"' if test_formula else "None"

    if mode == "power":
        sample_size = analysis_params.get("sample_size", 100)
        lines.append("result = model.find_power(")
        lines.append(f"    sample_size={sample_size},")
        lines.append(f'    target_test="{target_test}",')
        lines.append(f"    correction={corr_arg},")
        lines.append(f"    scenarios={scenarios},")
        lines.append(f'    summary="{summary}",')
        lines.append(f"    test_formula={tf_arg},")
        lines.append("    print_results=True,")
        lines.append("    return_results=True,")
        lines.append(")")
    else:
        ss_from = analysis_params.get("ss_from", 30)
        ss_to = analysis_params.get("ss_to", 200)
        ss_by = analysis_params.get("ss_by", 10)
        lines.append("result = model.find_sample_size(")
        lines.append(f"    from_size={ss_from},")
        lines.append(f"    to_size={ss_to},")
        lines.append(f"    by={ss_by},")
        lines.append(f'    target_test="{target_test}",')
        lines.append(f"    correction={corr_arg},")
        lines.append(f"    scenarios={scenarios},")
        lines.append(f'    summary="{summary}",')
        lines.append(f"    test_formula={tf_arg},")
        lines.append("    print_results=True,")
        lines.append("    return_results=True,")
        lines.append(")")

    return "\n".join(lines) + "\n"
